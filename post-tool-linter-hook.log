[2025-07-24T00:51:25.278Z] === POST-TOOL LINTER HOOK LOG ===
[2025-07-24T00:51:25.278Z] Date: 2025-07-24T00:51:25.278Z
[2025-07-24T00:51:25.278Z] Project: /Users/jeremyparker/Desktop/Claude Coding Projects/post-tool-stop-hook
[2025-07-24T00:51:25.278Z] Node Version: v23.9.0
[2025-07-24T00:51:25.278Z] Platform: darwin
[2025-07-24T00:51:25.278Z] 
[2025-07-24T00:51:25.278Z] === HOOK EXECUTION START ===
[2025-07-24T00:51:25.278Z] Tool: Edit
[2025-07-24T00:51:25.278Z] Session ID: 04d5b7c1-a50f-4f1a-9424-ae3bac9c3074
[2025-07-24T00:51:25.278Z] Hook input:
  Data: {
  "session_id": "04d5b7c1-a50f-4f1a-9424-ae3bac9c3074",
  "transcript_path": "/Users/jeremyparker/.claude/projects/-Users-jeremyparker-Desktop-Claude-Coding-Projects-post-tool-stop-hook/04d5b7c1-a50f-4f1a-9424-ae3bac9c3074.jsonl",
  "cwd": "/Users/jeremyparker/Desktop/Claude Coding Projects/post-tool-stop-hook",
  "hook_event_name": "PostToolUse",
  "tool_name": "Edit",
  "tool_input": {
    "file_path": "/Users/jeremyparker/Desktop/Claude Coding Projects/post-tool-stop-hook/post-tool-linter-hook.js",
    "old_string": "  // Handle timeout\n  setTimeout(() => {\n    log('\\nERROR: Hook timeout exceeded');\n    console.error('Hook timeout exceeded');\n    writeLogFile();\n    process.exit(0);\n  }, CONFIG.timeout + 5000);",
    "new_string": "  // Handle timeout\n  setTimeout(() => {\n    log('\\nERROR: Hook timeout exceeded');\n    writeLogFile();\n    process.exit(0);\n  }, CONFIG.timeout + 5000);"
  },
  "tool_response": {
    "filePath": "/Users/jeremyparker/Desktop/Claude Coding Projects/post-tool-stop-hook/post-tool-linter-hook.js",
    "oldString": "  // Handle timeout\n  setTimeout(() => {\n    log('\\nERROR: Hook timeout exceeded');\n    console.error('Hook timeout exceeded');\n    writeLogFile();\n    process.exit(0);\n  }, CONFIG.timeout + 5000);",
    "newString": "  // Handle timeout\n  setTimeout(() => {\n    log('\\nERROR: Hook timeout exceeded');\n    writeLogFile();\n    process.exit(0);\n  }, CONFIG.timeout + 5000);",
    "originalFile": "#!/usr/bin/env node\n\n/**\n * Post-Tool Linter Hook for Claude Code\n * \n * This hook runs after Claude Code uses file modification tools (Edit, Write, MultiEdit)\n * and automatically runs appropriate linters (ruff for Python, ESLint for JavaScript).\n * If linting errors are found, it prompts Claude to fix them before continuing.\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\n\n// Initialize logging\nlet logFile = null;\nlet logContent = [];\n\nfunction initializeLogging(projectPath) {\n  const logPath = path.join(projectPath, 'post-tool-linter-hook.log');\n  logFile = logPath;\n  logContent = [];\n  log('=== POST-TOOL LINTER HOOK LOG ===');\n  log(`Date: ${new Date().toISOString()}`);\n  log(`Project: ${projectPath}`);\n  log(`Node Version: ${process.version}`);\n  log(`Platform: ${process.platform}`);\n  log('');\n}\n\nfunction log(message, data = null) {\n  const timestamp = new Date().toISOString();\n  const logEntry = `[${timestamp}] ${message}`;\n  \n  // Only log to file, not stderr (keep stderr clean for Claude prompts)\n  logContent.push(logEntry);\n  \n  if (data !== null) {\n    const dataStr = JSON.stringify(data, null, 2);\n    logContent.push(`  Data: ${dataStr}`);\n  }\n}\n\nfunction writeLogFile() {\n  if (logFile && logContent.length > 0) {\n    try {\n      fs.writeFileSync(logFile, logContent.join('\\n') + '\\n');\n      // Don't log to stderr - keep it clean for Claude prompts\n    } catch (error) {\n      // Silently fail log file writes to avoid cluttering stderr\n    }\n  }\n}\n\n// Configuration\nconst CONFIG = {\n  timeout: 10000, // 10 seconds max for linting\n  enabledTools: ['Edit', 'Write', 'MultiEdit'],\n  linters: {\n    python: {\n      command: 'ruff check --format json',\n      fileExtensions: ['.py', '.pyi'],\n      configFiles: ['pyproject.toml', 'setup.py', 'requirements.txt', '.python-version', 'Pipfile']\n    },\n    javascript: {\n      command: 'eslint --format json',\n      fileExtensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'],\n      configFiles: ['package.json', 'tsconfig.json', '.eslintrc.json', '.eslintrc.js']\n    }\n  },\n  skipExtensions: ['.json', '.md', '.txt', '.yml', '.yaml', '.xml', '.csv', '.log']\n};\n\n// Utility functions\nfunction detectProjectType(projectPath) {\n  log(`Detecting project type for: ${projectPath}`);\n  \n  for (const [type, config] of Object.entries(CONFIG.linters)) {\n    log(`Checking for ${type} project indicators...`);\n    for (const configFile of config.configFiles) {\n      const configPath = path.join(projectPath, configFile);\n      const exists = fs.existsSync(configPath);\n      log(`  ${configFile}: ${exists ? 'FOUND' : 'not found'}`);\n      \n      if (exists) {\n        log(`Project type detected: ${type}`);\n        return type;\n      }\n    }\n  }\n  \n  log('No project type detected');\n  return null;\n}\n\nfunction getFileType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  log(`Getting file type for extension: ${ext}`);\n  \n  // Check if extension should be skipped\n  if (CONFIG.skipExtensions.includes(ext)) {\n    log(`Extension ${ext} is in skip list - no linting needed`);\n    return null;\n  }\n  \n  for (const [type, config] of Object.entries(CONFIG.linters)) {\n    if (config.fileExtensions.includes(ext)) {\n      log(`File type detected: ${type}`);\n      return type;\n    }\n  }\n  \n  log(`No linter configured for extension: ${ext}`);\n  return null;\n}\n\nfunction extractFilePaths(hookData) {\n  const paths = [];\n  log(`Extracting file paths from tool: ${hookData.tool_name}`);\n  \n  if (hookData.tool_name === 'Edit' || hookData.tool_name === 'Write') {\n    if (hookData.tool_input?.file_path) {\n      paths.push(hookData.tool_input.file_path);\n      log(`Found file path: ${hookData.tool_input.file_path}`);\n    }\n  } else if (hookData.tool_name === 'MultiEdit') {\n    if (hookData.tool_input?.file_path) {\n      paths.push(hookData.tool_input.file_path);\n      log(`Found file path: ${hookData.tool_input.file_path}`);\n    }\n  }\n  \n  const existingPaths = paths.filter(p => {\n    const exists = p && fs.existsSync(p);\n    log(`Checking path existence: ${p} - ${exists ? 'EXISTS' : 'NOT FOUND'}`);\n    return exists;\n  });\n  \n  log(`Total paths found: ${existingPaths.length}`);\n  return existingPaths;\n}\n\nasync function runPythonLinter(filePath, projectPath) {\n  log(`Running Python linter (ruff) on: ${filePath}`);\n  \n  try {\n    const command = `ruff check \"${filePath}\" --output-format json`;\n    log(`Executing command: ${command}`);\n    \n    const result = execSync(command, {\n      cwd: projectPath,\n      encoding: 'utf8',\n      timeout: CONFIG.timeout,\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n    \n    log(`Ruff executed successfully, parsing output...`);\n    const violations = JSON.parse(result || '[]');\n    log(`Found ${violations.length} violations`);\n    \n    return {\n      success: violations.length === 0,\n      linter: 'ruff',\n      file: filePath,\n      violations: violations.map(v => ({\n        line: v.location?.row || v.location?.start?.row || 0,\n        column: v.location?.column || v.location?.start?.column || 0,\n        code: v.code,\n        message: v.message,\n        severity: 'error',\n        fixable: v.fix !== null && v.fix !== undefined\n      }))\n    };\n  } catch (error) {\n    log(`Ruff execution failed with status: ${error.status}`);\n    \n    // Ruff returns non-zero exit code when violations found\n    if (error.status === 1 && error.stdout) {\n      try {\n        log(`Parsing error stdout for violations...`);\n        const violations = JSON.parse(error.stdout);\n        log(`Found ${violations.length} violations from error output`);\n        \n        return {\n          success: false,\n          linter: 'ruff',\n          file: filePath,\n          violations: violations.map(v => ({\n            line: v.location?.row || v.location?.start?.row || 0,\n            column: v.location?.column || v.location?.start?.column || 0,\n            code: v.code,\n            message: v.message,\n            severity: 'error',\n            fixable: v.fix !== null && v.fix !== undefined\n          }))\n        };\n      } catch (parseError) {\n        log(`Failed to parse ruff output: ${parseError.message}`);\n        return { success: true, linter: 'ruff', file: filePath, violations: [] };\n      }\n    }\n    \n    // Check if ruff is installed\n    if (error.message.includes('command not found') || error.message.includes('not recognized')) {\n      log('ERROR: Ruff is not installed');\n      return { success: true, linter: 'ruff', file: filePath, violations: [], skipped: true, reason: 'Ruff not installed' };\n    }\n    \n    log(`Unexpected error running ruff: ${error.message}`);\n    return { success: true, linter: 'ruff', file: filePath, violations: [] };\n  }\n}\n\nasync function runJavaScriptLinter(filePath, projectPath) {\n  try {\n    // Try to find eslint\n    let eslintCommand = 'eslint';\n    if (fs.existsSync(path.join(projectPath, 'node_modules', '.bin', 'eslint'))) {\n      eslintCommand = path.join(projectPath, 'node_modules', '.bin', 'eslint');\n    }\n    \n    const result = execSync(`\"${eslintCommand}\" \"${filePath}\" --format json`, {\n      cwd: projectPath,\n      encoding: 'utf8',\n      timeout: CONFIG.timeout,\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n    \n    const reports = JSON.parse(result || '[]');\n    const fileReport = reports[0] || { messages: [] };\n    \n    return {\n      success: fileReport.errorCount === 0 && fileReport.warningCount === 0,\n      linter: 'eslint',\n      file: filePath,\n      violations: fileReport.messages.map(m => ({\n        line: m.line,\n        column: m.column,\n        severity: m.severity === 2 ? 'error' : 'warning',\n        message: m.message,\n        code: m.ruleId,\n        fixable: m.fix !== undefined\n      }))\n    };\n  } catch (error) {\n    // ESLint returns non-zero when violations found\n    if (error.stdout) {\n      try {\n        const reports = JSON.parse(error.stdout);\n        const fileReport = reports[0] || { messages: [] };\n        \n        return {\n          success: fileReport.errorCount === 0,\n          linter: 'eslint',\n          file: filePath,\n          violations: fileReport.messages.map(m => ({\n            line: m.line,\n            column: m.column,\n            severity: m.severity === 2 ? 'error' : 'warning',\n            message: m.message,\n            code: m.ruleId,\n            fixable: m.fix !== undefined\n          }))\n        };\n      } catch (parseError) {\n        return { success: true, linter: 'eslint', file: filePath, violations: [] };\n      }\n    }\n    \n    // Check if eslint is installed\n    if (error.message.includes('command not found') || error.message.includes('not recognized')) {\n      return { success: true, linter: 'eslint', file: filePath, violations: [], skipped: true, reason: 'ESLint not installed' };\n    }\n    \n    return { success: true, linter: 'eslint', file: filePath, violations: [] };\n  }\n}\n\nasync function lintFile(filePath, projectPath) {\n  log(`\\n--- Linting file: ${filePath} ---`);\n  \n  const fileType = getFileType(filePath);\n  const projectType = detectProjectType(projectPath);\n  const linterType = fileType || projectType;\n  \n  log(`File type: ${fileType || 'none'}, Project type: ${projectType || 'none'}`);\n  log(`Selected linter type: ${linterType || 'none'}`);\n  \n  if (!linterType) {\n    log('No linter configured for this file/project type');\n    return { success: true, file: filePath, reason: 'No linter configured for this file type' };\n  }\n  \n  switch (linterType) {\n    case 'python':\n      return await runPythonLinter(filePath, projectPath);\n    case 'javascript':\n      return await runJavaScriptLinter(filePath, projectPath);\n    default:\n      log(`Unsupported linter type: ${linterType}`);\n      return { success: true, file: filePath, reason: 'Unsupported file type' };\n  }\n}\n\nfunction formatLinterPrompt(results) {\n  const resultsWithViolations = results.filter(r => r.violations && r.violations.length > 0);\n  \n  if (resultsWithViolations.length === 0) {\n    return '';\n  }\n  \n  const totalViolations = resultsWithViolations.reduce((sum, r) => sum + r.violations.length, 0);\n  const errors = resultsWithViolations.flatMap(r => \n    r.violations.filter(v => v.severity === 'error')\n  );\n  const warnings = resultsWithViolations.flatMap(r => \n    r.violations.filter(v => v.severity === 'warning')\n  );\n  \n  let prompt = `# 🚨 LINTING ERRORS DETECTED - FIX REQUIRED\\n\\n`;\n  prompt += `Found ${totalViolations} linting issue${totalViolations !== 1 ? 's' : ''} `;\n  prompt += `(${errors.length} error${errors.length !== 1 ? 's' : ''}, `;\n  prompt += `${warnings.length} warning${warnings.length !== 1 ? 's' : ''}):\\n\\n`;\n  \n  // Group by file\n  for (const result of resultsWithViolations) {\n    prompt += `## ${path.basename(result.file)} (${result.linter})\\n\\n`;\n    \n    // Sort violations by line number\n    const sortedViolations = result.violations.sort((a, b) => a.line - b.line);\n    \n    for (const violation of sortedViolations) {\n      const icon = violation.severity === 'error' ? '❌' : '⚠️';\n      const fixable = violation.fixable ? ' (auto-fixable)' : '';\n      prompt += `${icon} Line ${violation.line}:${violation.column} - `;\n      prompt += `${violation.message}`;\n      if (violation.code) {\n        prompt += ` [${violation.code}]`;\n      }\n      prompt += fixable;\n      prompt += '\\n';\n    }\n    prompt += '\\n';\n  }\n  \n  prompt += `## REQUIRED ACTIONS:\\n\\n`;\n  prompt += `1. **STOP all other work** - Code quality must be maintained\\n`;\n  prompt += `2. **Fix all errors first** (${errors.length} error${errors.length !== 1 ? 's' : ''})\\n`;\n  prompt += `3. **Then fix warnings** (${warnings.length} warning${warnings.length !== 1 ? 's' : ''})\\n`;\n  prompt += `4. **Use the Edit tool** to correct each issue\\n`;\n  prompt += `5. **Preserve functionality** while fixing style issues\\n\\n`;\n  \n  const hasFixable = resultsWithViolations.some(r => \n    r.violations.some(v => v.fixable)\n  );\n  \n  if (hasFixable) {\n    prompt += `💡 **Tip**: Some issues are auto-fixable. `;\n    prompt += `For Python, you could run \\`ruff check --fix\\`. `;\n    prompt += `For JavaScript, you could run \\`eslint --fix\\`.\\n\\n`;\n  }\n  \n  prompt += `Remember: Clean code is maintainable code. Fix these issues before proceeding.\\n`;\n  \n  return prompt;\n}\n\n// Main execution\nasync function main() {\n  let inputData = '';\n  \n  // Read stdin\n  process.stdin.setEncoding('utf8');\n  process.stdin.on('data', chunk => inputData += chunk);\n  \n  process.stdin.on('end', async () => {\n    let projectPath = process.cwd();\n    \n    try {\n      // Parse input\n      const hookData = JSON.parse(inputData);\n      projectPath = hookData.cwd || process.cwd();\n      \n      // Initialize logging with project path\n      initializeLogging(projectPath);\n      \n      log('=== HOOK EXECUTION START ===');\n      log(`Tool: ${hookData.tool_name}`);\n      log(`Session ID: ${hookData.session_id || 'unknown'}`);\n      log('Hook input:', hookData);\n      \n      // Skip if not a file modification tool\n      if (!CONFIG.enabledTools.includes(hookData.tool_name)) {\n        log(`Tool ${hookData.tool_name} is not in enabled tools list, skipping`);\n        writeLogFile();\n        process.exit(0);\n      }\n      \n      // Skip if tool execution failed\n      if (hookData.tool_output && !hookData.tool_output.success) {\n        log('Tool execution failed, skipping linting');\n        writeLogFile();\n        process.exit(0);\n      }\n      \n      // Extract file paths\n      const filePaths = extractFilePaths(hookData);\n      \n      if (filePaths.length === 0) {\n        log('No file paths extracted, nothing to lint');\n        writeLogFile();\n        process.exit(0);\n      }\n      \n      log(`\\nStarting linting for ${filePaths.length} file(s)...`);\n      \n      // Run linters on all modified files\n      const results = await Promise.all(\n        filePaths.map(fp => lintFile(fp, projectPath))\n      );\n      \n      log('\\n=== LINTING RESULTS ===');\n      results.forEach((result, index) => {\n        log(`File ${index + 1}: ${result.file}`);\n        log(`  Success: ${result.success}`);\n        log(`  Linter: ${result.linter || 'none'}`);\n        log(`  Violations: ${result.violations?.length || 0}`);\n        if (result.skipped) log(`  SKIPPED: Linter not installed`);\n        if (result.reason) log(`  Reason: ${result.reason}`);\n      });\n      \n      // Check if any linting issues were found\n      const hasIssues = results.some(r => !r.success && !r.skipped);\n      log(`\\nHas linting issues: ${hasIssues}`);\n      \n      if (hasIssues) {\n        // Format and output prompt for Claude\n        const prompt = formatLinterPrompt(results);\n        if (prompt) {\n          log('\\nGenerating prompt for Claude...');\n          log(`Prompt length: ${prompt.length} characters`);\n          process.stderr.write(prompt);\n          log('\\nExiting with code 2 - prompting Claude to fix issues');\n          writeLogFile();\n          process.exit(2); // Force continuation with prompt\n        }\n      }\n      \n      // Log summary if linters were skipped  \n      const skippedResults = results.filter(r => r.skipped);\n      if (skippedResults.length > 0) {\n        log(`\\nNote: ${skippedResults.length} linter(s) were skipped (not installed)`);\n      }\n      \n      log('\\nNo linting issues found or all skipped');\n      log('Exiting with code 0 - success');\n      writeLogFile();\n      process.exit(0);\n    } catch (error) {\n      // Don't output hook errors to stderr - just log them\n      log(`\\nERROR: ${error.message}`);\n      log(error.stack);\n      writeLogFile();\n      // Don't block Claude on hook errors\n      process.exit(0);\n    }\n  });\n  \n  // Handle timeout\n  setTimeout(() => {\n    log('\\nERROR: Hook timeout exceeded');\n    console.error('Hook timeout exceeded');\n    writeLogFile();\n    process.exit(0);\n  }, CONFIG.timeout + 5000);\n}\n\n// Run the hook\nmain();",
    "structuredPatch": [
      {
        "oldStart": 469,
        "oldLines": 7,
        "newStart": 469,
        "newLines": 6,
        "lines": [
          "   // Handle timeout",
          "   setTimeout(() => {",
          "     log('\\nERROR: Hook timeout exceeded');",
          "-    console.error('Hook timeout exceeded');",
          "     writeLogFile();",
          "     process.exit(0);",
          "   }, CONFIG.timeout + 5000);"
        ]
      }
    ],
    "userModified": false,
    "replaceAll": false
  }
}
[2025-07-24T00:51:25.279Z] Extracting file paths from tool: Edit
[2025-07-24T00:51:25.279Z] Found file path: /Users/jeremyparker/Desktop/Claude Coding Projects/post-tool-stop-hook/post-tool-linter-hook.js
[2025-07-24T00:51:25.279Z] Checking path existence: /Users/jeremyparker/Desktop/Claude Coding Projects/post-tool-stop-hook/post-tool-linter-hook.js - EXISTS
[2025-07-24T00:51:25.279Z] Total paths found: 1
[2025-07-24T00:51:25.279Z] 
Starting linting for 1 file(s)...
[2025-07-24T00:51:25.279Z] 
--- Linting file: /Users/jeremyparker/Desktop/Claude Coding Projects/post-tool-stop-hook/post-tool-linter-hook.js ---
[2025-07-24T00:51:25.279Z] Getting file type for extension: .js
[2025-07-24T00:51:25.279Z] File type detected: javascript
[2025-07-24T00:51:25.279Z] Detecting project type for: /Users/jeremyparker/Desktop/Claude Coding Projects/post-tool-stop-hook
[2025-07-24T00:51:25.279Z] Checking for python project indicators...
[2025-07-24T00:51:25.279Z]   pyproject.toml: not found
[2025-07-24T00:51:25.279Z]   setup.py: not found
[2025-07-24T00:51:25.279Z]   requirements.txt: not found
[2025-07-24T00:51:25.279Z]   .python-version: not found
[2025-07-24T00:51:25.279Z]   Pipfile: not found
[2025-07-24T00:51:25.279Z] Checking for javascript project indicators...
[2025-07-24T00:51:25.279Z]   package.json: not found
[2025-07-24T00:51:25.279Z]   tsconfig.json: not found
[2025-07-24T00:51:25.279Z]   .eslintrc.json: not found
[2025-07-24T00:51:25.279Z]   .eslintrc.js: not found
[2025-07-24T00:51:25.279Z] No project type detected
[2025-07-24T00:51:25.279Z] File type: javascript, Project type: none
[2025-07-24T00:51:25.279Z] Selected linter type: javascript
[2025-07-24T00:51:25.283Z] 
=== LINTING RESULTS ===
[2025-07-24T00:51:25.283Z] File 1: /Users/jeremyparker/Desktop/Claude Coding Projects/post-tool-stop-hook/post-tool-linter-hook.js
[2025-07-24T00:51:25.283Z]   Success: true
[2025-07-24T00:51:25.283Z]   Linter: eslint
[2025-07-24T00:51:25.283Z]   Violations: 0
[2025-07-24T00:51:25.283Z]   SKIPPED: Linter not installed
[2025-07-24T00:51:25.283Z]   Reason: ESLint not installed
[2025-07-24T00:51:25.283Z] 
Has linting issues: false
[2025-07-24T00:51:25.283Z] 
Note: 1 linter(s) were skipped (not installed)
[2025-07-24T00:51:25.283Z] 
No linting issues found or all skipped
[2025-07-24T00:51:25.283Z] Exiting with code 0 - success
